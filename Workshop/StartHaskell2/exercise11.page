# 『ファンクターからアプリカティブファンクターへ』　練習問題


## Functerインスタンスを考える

次のもののFuncterインスタンスを考えてみよう。実装はファンクター則を満たしているだろうか。また、それ以外の実装はありえるだろうか。

~~~ {.haskell}
data Maybe a     = Nothing | Just a

data [] a        -- リスト 

data Tree a      = Leaf | Branch a (Tree a) (Tree a) 

data Either a b  = Left a | Right b

data (,) a b     -- タプル
~~~

たとえばリストだったら、以下のように書く。

~~~ {.haskell}
instance Functor [] where
  fmap f xs = undefined
~~~


ヒント：

次のMaybeのFuncter実装は、ファンクター則を満たしているだろうか。

~~~ {.haskell}
instance Functor Maybe where
  fmap f Nothing  = Nothing
  fmap f (Just a) = Nothing
~~~

または、次の実装ではどうだろうか。

~~~ {.haskell}
instance Functor Maybe where
  fmap f Nothing  = Nothing
  fmap f (Just a) = Just a
~~~


参考：[The Typeclassopedia](http://snak.tdiary.net/20091020.html)

* * * * *


## ファンクター則を破るとどうなるの？


（なんか面白い例を載せる）

参考：ファンクター則は、一般的には準同型と呼ばれる。 [ja.wikipedia.org/wiki/準同系](http://ja.wikipedia.org/wiki/準同系)

* * * * *

## モナドを書き直す（アプリカティブスタイル）

次のIOモナドを使ったコードを、アプリカティブスタイルに書き直してみよう。


~~~ {.haskell}
main :: IO ()
main = do
  z <- add
  print z


add :: IO Int
add = do
  x <- readLn
  y <- readLn
  return (x+y)
~~~

次のコードもアプリカティブスタイルに書き直してみよう。


~~~ {.haskell}
main :: IO ()
main = do
  putStrLn "What's your name?"
  name <- getLine
  putStrLn $ "Hello, " ++ name
~~~

* * * * *

## パーサーコンビネータ（アプリカティブスタイル）

次のBNFを考える。

~~~
<formula> ::= 0 | 1 | 2 | 3 |
              -<formula> | (<formula>*<formula>) | (<formula>+<formula>)
~~~

これを解析して計算するパーサーコンビネーターをモナドスタイルで書いたのが次のコードである。これをアプリカティブスタイルに書き直してみよう。

~~~ {.haskell}
import Text.ParserCombinators.ReadP
import Control.Applicative

main :: IO ()
main = do
  xs <- getLine
  print $ readP_to_S formula xs

formula = do
  n <- choise [ number, minus, times, add ]
  return n

number = do
  x <- choice [ char '0', char '1', char '2', char '3' ]
  return (read[x])

minus = do
  char '-'
  x <- formula
  return (-x)

times = do
  char '('
  x <- formula
  char '*'
  y <- formula
  char ')'
  return (x * y)

add = do
  char '('
  x <- formula
  char '+'
  y <- formula
  char ')'
  return (x + y)


~~~

ヒント：[Applicativeのススメ](http://d.hatena.ne.jp/kazu-yamamoto/20101211/1292021817)に、アプリカティブを使ったパーサーコンビネーターの書き方が載っています。



出典：[ACM国際大学対抗プログラミングコンテスト 2008 国内予選 問題C](http://www.acm-japan.org/past-icpc/domestic2008/problems/all_ja.html) の改変

* * * * *

## ZipList（アプリカティブスタイル）

ZipListを使って、Data.Listにある[transpose](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-List.html#v:transpose)関数を実装してみよう。


~~~ {.haskell}
transpose :: [[a]] -> [[a]]

transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]
~~~

テキスト(p.253)にある sequenceA 関数と比較してみよう。


参考：Conor McBride and Ross Paterson. [Applicative Programming with Effects.](http://www.soi.city.ac.uk/~ross/papers/Applicative.html) J. Funct. Program., 18(1):pages 1-13 (2008).

* * * * *