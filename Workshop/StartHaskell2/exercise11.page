# 『ファンクターからアプリカティブファンクターへ』　練習問題


## Functerインスタンスを考える

次のもののFuncterインスタンスを考えてみよう。実装はファンクター則を満たしているだろうか。また、それ以外の実装はありえるだろうか。

~~~ {.haskell}
data Maybe a     = Nothing | Just a

data [] a        -- リスト 

data Tree a      = Leaf | Branch a (Tree a) (Tree a) 

data Either a b  = Left a | Right b

data (,) a b     -- タプル
~~~

たとえばリストだったら、以下のように書く。

~~~ {.haskell}
instance Functor [] where
  fmap f xs = undefined
~~~


ヒント：

次のMaybeのFuncter実装は、ファンクター則を満たしているだろうか。

~~~ {.haskell}
instance Functor Maybe where
  fmap f Nothing  = Nothing
  fmap f (Just a) = Nothing
~~~

または、次の実装ではどうだろうか。

~~~ {.haskell}
instance Functor Maybe where
  fmap f Nothing  = Nothing
  fmap f (Just a) = Just a
~~~


参考：[The Typeclassopedia](http://snak.tdiary.net/20091020.html)

* * * * *


## ファンクター則を破るとどうなるの？


（なんか面白い例を載せる）

参考：ファンクター則は、一般的には準同型と呼ばれる。 [ja.wikipedia.org/wiki/準同系](http://ja.wikipedia.org/wiki/準同系)

* * * * *

## モナドを書き直す（アプリカティブスタイル）

次のIOモナドを使ったコードを、アプリカティブスタイルに書き直してみよう。


~~~ {.haskell}
main :: IO ()
main = do
  z <- add
  print z


add :: IO Int
add = do
  x <- readLn
  y <- readLn
  return (x+y)
~~~

次のコードもアプリカティブスタイルに書き直してみよう。


~~~ {.haskell}
main :: IO ()
main = do
  putStrLn "What's your name?"
  name <- getLine
  putStrLn $ "Hello, " ++ name
~~~

* * * * *

## ZipList（アプリカティブスタイル）

ZipListを使って、Data.Listにある[transpose](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-List.html#v:transpose)関数を実装してみよう。


~~~ {.haskell}
transpose :: [[a]] -> [[a]]

transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]
~~~

テキスト(p.253)にある sequenceA 関数と比較してみよう。


参考：Conor McBride and Ross Paterson. [Applicative Programming with Effects.](http://www.soi.city.ac.uk/~ross/papers/Applicative.html) J. Funct. Program., 18(1):pages 1-13 (2008).

* * * * *