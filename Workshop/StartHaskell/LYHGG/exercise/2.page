# 2. 型を信じろ！

1. null関数の型はこんな感じです。これはどういう意味でしたか。(p.24)


~~~ { .haskell }
ghci> :t null
null :: [a] -> Bool

~~~

またtake関数の型はどうでしょうか。

* * * * *

2. 以下の式の型を調べましょう。

~~~ { .haskell }
'a'
'a' == 'a'
("Hello", "world!")
100
1000 / 10
show
take 3 [1..]
[init , tail , reverse]

~~~

* * * * *

3. 以下の関数がどういう動きをするか、型から想像できますか。


~~~ { .haskell }
id        :: a -> a
splitAt   :: Int -> [a] -> ([a],[a])
takeWhile :: (a -> Bool) -> [a] -> [a]

~~~

* * * * *

4. succ関数とは反対に、ひとつ前の値を返す関数は何ですか。（ヒント：[Hoogle](http://www.haskell.org/hoogle/)で型を検索してみよう）

~~~ { .haskell }
succ :: Enum a => a -> a
~~~

* * * * *

5. 与えらえた型から値を想像してみましょう。

ある日、ghciを使って遊んでいて以下のような結果が得られました。

~~~ {.haskell}
Prelude> :t XXX
XXX :: Num t => [(t, [a] -> a)]
~~~

ところがXXXの部分を覚えていません。
XXXはどのような式になるでしょうか。
(答は一つではありません)

* * * * *

6. 与えらえた型から値を想像してみましょう、その２．

以下の型になる式を探してみよう。

~~~ {.haskell}
[Char]
Integer
[Double]
(a, b, c)
Num a => a
Num a => [a]
(a, a)
~~~

* * * * *

7. Eq クラスに属する型にはどんなものがありますか。 (ヒント：[Hoogle](http://www.haskell.org/hoogle/)で Eq を検索してみよう)

また Eq クラスと Show クラスの両方に属する型はありますか。

* * * * *

8. Bounded クラスに属する型を探して、その上限値を表示してみよう。 (p.32)

* * * * *

9. 円の直径を求めるcircumference関数の型を Float -> Float から Double -> Double に書き換えると、値の制度が倍になります (p.25)

~~~ {.haskell}
circumference :: Float -> Float
circumference r = 2 * pi * r
~~~

しかし, この関数の型を Int -> Int に書き換えるとエラーになります。何故ですか。（ヒント： pi の型を確認してみよう）

* * * * *

10. 以下の式は型エラーになります。何故ですか。

~~~ {.haskell}
Prelude> (1 :: Int) + (1.0 :: Double)
~~~

しかし、以下の式はえらーになりません。何故ですか。(P.33)

~~~ {.haskell}
Prelude> 1 + 1.0
~~~

* * * * *

11. 上述の問題で, Int型とDouble型は足せないことを見ました。

この２つを足したいときは, 明示的に型変換をする必要があり、そのための関数が用意されています。(P.33)

~~~ {.haskell}
fromIntegral :: (Num b, Integral a) => a -> b
~~~

この関数を使って, 1 + 1.0 をInt型として足してみましょう。
