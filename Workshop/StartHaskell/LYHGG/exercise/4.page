# Hello 再帰！

1. リストの長さを返す関数を、再帰を使って自分で書いてみよう。

~~~ {.haskell}
myLength   :: [a] -> Int
~~~

* * * * *

2. リストの要素を全部足す関数と、全部かける関数を、再帰を使って書いてみよう。

~~~ {.haskell}
mySum      :: [Int] -> Int
myProduct  :: [Int] -> Int
~~~

実行例

~~~ {.haskell}
ghci> mySum [1,2,3,4]
10
ghci> myProduct [1,2,3,4]
24
~~~

* * * * *
3. 整数のリストを受け取って、奇数だけのリストと偶数だけのリストに分ける関数を、再帰を使って書いてみよう。

~~~ {.haskell}
oddEven :: [Int] -> ([Int],[Int])
~~~

実行例

~~~ {.haskell}
ghci> oddEven [1,4,5,6,7,10,11]
([1,5,7,11], [4,6,10])
~~~

* * * * *

4. コラッツ数列を返す関数を実装してみよう。

与えられた数nに、以下の操作を繰り返し適用して、数列を生成する。

- nが偶数なら、n/2 を返す
- nが奇数なら、2*n+1 を返す

たとえば 13 から始めた場合、以下のような数列が得られる。

~~~
13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
~~~

このような数列（コラッツ数列）は、最終的には必ず1にたどり着くと予想されているが、未解決問題となっている。  [コラッツ問題 Wikipedia](http://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%A9%E3%83%83%E3%83%84%E3%81%AE%E5%95%8F%E9%A1%8C)

コラッツ数列を返す関数を実装してみよう。


~~~ {.haskell}
collatz :: Int -> [Int]
~~~

実行例

~~~ {.haskell}
ghci> collatz 13
[13,40,20,10,5,16,8,4,2,1]
~~~

